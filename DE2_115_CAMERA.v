// --------------------------------------------------------------------
// Copyright (c) 2010 by Terasic Technologies Inc. 
// --------------------------------------------------------------------
//
// Permission:
//
//   Terasic grants permission to use and modify this code for use
//   in synthesis for all Terasic Development Boards and Altera Development 
//   Kits made by Terasic.  Other use of this code, including the selling 
//   ,duplication, or modification of any portion is strictly prohibited.
//
// Disclaimer:
//
//   This VHDL/Verilog or C/C++ source code is intended as a design reference
//   which illustrates how these types of functions can be implemented.
//   It is the user's responsibility to verify their design for
//   consistency and functionality through the use of formal
//   verification methods.  Terasic provides no warranty regarding the use 
//   or functionality of this code.
//
// --------------------------------------------------------------------
//           
//                     Terasic Technologies Inc
//                     356 Fu-Shin E. Rd Sec. 1. JhuBei City,
//                     HsinChu County, Taiwan
//                     302
//
//                     web: http://www.terasic.com/
//                     email: support@terasic.com
//
// --------------------------------------------------------------------
//
// Major Functions:	DE2_115 D5M+VGA 640*480 800*600 solution
//
// --------------------------------------------------------------------
//
// Revision History :
// --------------------------------------------------------------------
//   Ver  :| Author            :| Mod. Date :| Changes Made:
//   V1.0 :| Johnny FAN Peli Li:| 22/07/2010:| Initial Revision
// --------------------------------------------------------------------
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
//to set the VGA solution
`include "VGA_Param.h" 

module DE2_115_CAMERA(

//////////// CLOCK //////////
input					CLOCK_50,
input					CLOCK2_50,
input					CLOCK3_50,

//////////// Sma //////////
input					SMA_CLKIN,
output				SMA_CLKOUT,

//////////// LED //////////
output	[8:0]		LEDG,
output	[17:0]	LEDR,

//////////// KEY //////////
input		[3:0]		KEY,

//////////// EJTAG //////////
inout		[6:0]		EX_IO,

//////////// SW //////////
input		[17:0]	SW,

//////////// SEG7 //////////
output	[6:0]		HEX0,
output	[6:0]		HEX1,
output	[6:0]		HEX2,
output	[6:0]		HEX3,
output	[6:0]		HEX4,
output	[6:0]		HEX5,
output	[6:0]		HEX6,
output	[6:0]		HEX7,

//////////// LCD //////////
output				LCD_BLON,
inout		[7:0]		LCD_DATA,
output				LCD_EN,
output				LCD_ON,
output				LCD_RS,
output				LCD_RW,

//////////// RS232 //////////
output				UART_CTS,
input					UART_RTS,
input					UART_RXD,
output				UART_TXD,

//////////// PS2 for Keyboard and Mouse //////////
inout					PS2_CLK,
inout					PS2_CLK2,
inout					PS2_DAT,
inout					PS2_DAT2,

//////////// SDCARD //////////
output				SD_CLK,
inout					SD_CMD,
inout		[3:0]		SD_DAT,
input					SD_WP_N,

//////////// VGA //////////
output	[7:0]		VGA_B,
output				VGA_BLANK_N,
output				VGA_CLK,
output	[7:0]		VGA_G,
output				VGA_HS,
output	[7:0]		VGA_R,
output				VGA_SYNC_N,
output				VGA_VS,

//////////// Audio //////////
input					AUD_ADCDAT,
inout					AUD_ADCLRCK,
inout					AUD_BCLK,
output				AUD_DACDAT,
inout					AUD_DACLRCK,
output				AUD_XCK,

//////////// I2C for EEPROM //////////
output				EEP_I2C_SCLK,
inout					EEP_I2C_SDAT,

//////////// I2C for Audio Tv-Decoder  //////////
output				I2C_SCLK,
inout					I2C_SDAT,

//////////// Ethernet 0 //////////
output				ENET0_GTX_CLK,
input					ENET0_INT_N,
input					ENET0_LINK100,
output				ENET0_MDC,
inout					ENET0_MDIO,
output				ENET0_RST_N,
input					ENET0_RX_CLK,
input					ENET0_RX_COL,
input					ENET0_RX_CRS,
input		[3:0]		ENET0_RX_DATA,
input					ENET0_RX_DV,
input		         ENET0_RX_ER,
input		         ENET0_TX_CLK,
output	[3:0]		ENET0_TX_DATA,
output		      ENET0_TX_EN,
output		      ENET0_TX_ER,
input		         ENETCLK_25,

//////////// Ethernet 1 //////////
output				ENET1_GTX_CLK,
input					ENET1_INT_N,
input		         ENET1_LINK100,
output		      ENET1_MDC,
inout					ENET1_MDIO,
output		      ENET1_RST_N,
input		         ENET1_RX_CLK,
input		         ENET1_RX_COL,
input		         ENET1_RX_CRS,
input		[3:0]		ENET1_RX_DATA,
input					ENET1_RX_DV,
input		         ENET1_RX_ER,
input		         ENET1_TX_CLK,
output	[3:0]		ENET1_TX_DATA,
output		      ENET1_TX_EN,
output		      ENET1_TX_ER,

//////////// TV Decoder //////////
input					TD_CLK27,
input		[7:0]		TD_DATA,
input		         TD_HS,
output		      TD_RESET_N,
input		         TD_VS,

//////////// USB 2.0 OTG //////////
output	[1:0]		OTG_ADDR,
output				OTG_CS_N,
output	[1:0]		OTG_DACK_N,
inout		[15:0]	OTG_DATA,
input		[1:0]		OTG_DREQ,
inout					OTG_FSPEED,
input		[1:0]		OTG_INT,
inout					OTG_LSPEED,
output				OTG_RD_N,
output				OTG_RST_N,
output				OTG_WE_N,

//////////// IR Receiver //////////
input					IRDA_RXD,

//////////// SDRAM //////////
output	[12:0]	DRAM_ADDR,
output	[1:0]		DRAM_BA,
output				DRAM_CAS_N,
output				DRAM_CKE,
output				DRAM_CLK,
output				DRAM_CS_N,
inout		[31:0]	DRAM_DQ,
output	[3:0]		DRAM_DQM,
output				DRAM_RAS_N,
output				DRAM_WE_N,

//////////// SRAM //////////
output	[19:0]	SRAM_ADDR,
output				SRAM_CE_N,
inout		[15:0]	SRAM_DQ,
output				SRAM_LB_N,
output				SRAM_OE_N,
output				SRAM_UB_N,
output				SRAM_WE_N,

//////////// Flash //////////
output	[22:0]	FL_ADDR,
output				FL_CE_N,
inout		[7:0]		FL_DQ,
output				FL_OE_N,
output				FL_RST_N,
input					FL_RY,
output				FL_WE_N,
output				FL_WP_N,

//////////// GPIO, GPIO connect to D5M - 5M Pixel Camera //////////
input		[11:0]	D5M_D,
input					D5M_FVAL,
input					D5M_LVAL,
input					D5M_PIXLCLK,
output				D5M_RESET_N,
output				D5M_SCLK,
inout					D5M_SDATA,
input					D5M_STROBE,
output				D5M_TRIGGER,
output				D5M_XCLKIN
);

wire	[15:0]	Read_DATA1;
wire	[15:0]	Read_DATA2;

wire	[11:0]	mCCD_DATA;
wire				mCCD_DVAL;
wire				mCCD_DVAL_d;
wire	[15:0]	X_Cont;
wire	[15:0]	Y_Cont;
wire	[9:0]		X_ADDR;
wire	[31:0]	Frame_Cont;
wire				DLY_RST_0;
wire				DLY_RST_1;
wire				DLY_RST_2;
wire				DLY_RST_3;
wire				DLY_RST_4;
wire				Read;
reg	[11:0]	rCCD_DATA;
reg				rCCD_LVAL;
reg				rCCD_FVAL;
wire	[11:0]	sCCD_R;
wire	[11:0]	sCCD_G;
wire	[11:0]	sCCD_B;
wire	[11:0]	sCCD_GS;
wire	[11:0]	sCCD_GaussianFilter;
wire	[11:0]	sCCD_MedianFilter;
wire	[11:0]	sCCD_SharpeningFilter;
wire	[11:0]	sCCD_Sobel;
wire	[11:0]	sCCD_Downsampled;

wire	[11:0]	sCCD_SRed;
wire	[11:0]	sCCD_SGreen;
wire	[11:0]	sCCD_SBlue;

wire	[11:0]	Filter_Red;
wire	[11:0]	Filter_Green;
wire	[11:0]	Filter_Blue;
wire				Filter_Val;

wire	[11:0]	Comp_Red;
wire	[11:0]	Comp_Green;
wire	[11:0]	Comp_Blue;

wire				sCCD_DVAL;

wire				sdram_ctrl_clk;
wire	[9:0]		oVGA_R;   				//	VGA Red[9:0]
wire	[9:0]		oVGA_G;	 				//	VGA Green[9:0]
wire	[9:0]		oVGA_B;   				//	VGA Blue[9:0]
	
//power on start
wire				auto_start;
//vga
wire	[9:0]		final_r;
wire	[9:0]		final_g;
wire	[9:0]		final_b;

// filter
wire	[19:0]	filter_addr0, filter_addr1;
wire	[11:0]	filter_rdata0, filter_rdata1;
wire	[9:0]		filter1_rdata0, filter1_rdata1;
wire	[9:0]		filter2_rdata0, filter2_rdata1;
wire	[11:0]	filter4_rdata0, filter4_rdata1;
wire	[9:0]		filter3_rdata; 
wire	[9:0]		pro_data_r, pro_data_g, pro_data_b;
wire	[2:0] 	pro_data_trans;
wire	[9:0]		now_x, now_y;
wire	[6:0]		pos_x1, pos_y1;
wire	[6:0]		pos_x2, pos_y2;
wire	[6:0]		pos_x3, pos_y3;
wire	[9:0]		filter_width;
wire	[9:0]		filter_height;
wire				slt;
wire	[1:0]		style_mode;

// viola, save_pic
wire	[15:0]	sram_addr, sram_addr1, sram_addr2;
wire	[15:0]	sram_wdata, sram_rdata;
wire				sram_wren, sram_wren1, sram_wren2;
wire				model_start;
wire				model_finish;
wire	[3:0]		save_state;
wire	[1:0]		face_num;
wire	[3:0]		viola_state;
wire	[6:0]		viola_col, viola_row;
wire	[15:0]	viola_frame;
wire	[15:0]	skin_counter;
wire	[15:0]	hair_counter;
wire	[6:0]		eye_x[0:2][0:1], eye_y[0:2][0:1];

// rs232
wire	[16:0]	sram_rs232_raddr, sram_rs232_waddr;
wire	[7:0]		sram_rs232_rdata, sram_rs232_wdata;
wire				sram_rs232_wren, rs232_finish;

reg	[16:0]	sram_rs232_raddr_r, sram_rs232_waddr_r;
reg	[7:0]		sram_rs232_rdata_r, sram_rs232_wdata_r;
reg				sram_rs232_wren_r;
reg	[1:0]		style_mode_r, style_mode_w;

reg	[10:0]	ref_per, ref_per_init;



assign sram_rs232_wren	= (now_x<640 && now_x>=0 && now_y<480 && now_y >=0) ? 1'b1 : 1'b0;
assign sram_rs232_waddr = now_y/2 * 320 + now_x/2;
assign sram_rs232_wdata = {final_r[9:7], final_g[9:7], final_b[9:8]};
assign style_mode			= style_mode_r;

assign D5M_TRIGGER		=	1'b1;  // tRIGGER
assign D5M_RESET_N		=	DLY_RST_1;
assign VGA_CTRL_CLK		= ~VGA_CLK;

assign LEDR					=	SW;
assign LEDG					=	Y_Cont;
//assign	UART_TXD = UART_RXD;

//fetch the high 8 bits
assign VGA_R				= oVGA_R[9:2];
assign VGA_G				= oVGA_G[9:2];
assign VGA_B				= oVGA_B[9:2];
assign auto_start			= ((KEY[0])&&(DLY_RST_3)&&(!DLY_RST_4))? 1'b1:1'b0;

assign filter_width		= (style_mode == 2'd3) ? 10'd220 : (style_mode == 2'd2) ? 10'd80 : (style_mode == 2'd1) ? 10'd240 : 10'd290;
assign filter_height		= (style_mode == 2'd3) ? 10'd80  : (style_mode == 2'd2) ? 10'd80 : (style_mode == 2'd1) ? 10'd240 : 10'd160;
assign filter_rdata0		= (style_mode == 2'd3) ? filter4_rdata0 : (style_mode == 2'd1) ? filter2_rdata0 : filter1_rdata0;
assign filter_rdata1		= (style_mode == 2'd3) ? filter4_rdata1 : (style_mode == 2'd1) ? filter2_rdata1 : filter1_rdata1;

assign sram_addr			= SW[16] ? SW[14:0] : (save_state==2'b0 || save_state==2'b1) ? sram_addr1 : sram_addr2;
assign sram_wren			= SW[16] ? 1'b0 : ((save_state==2'b0 || save_state==2'b1) ? sram_wren1 : sram_wren2);

`ifdef VGA_640x480p60
RAW2RGB		u4	(	
	.iCLK(D5M_PIXLCLK),
	.iRST(DLY_RST_1),
	.iDATA(mCCD_DATA),
	.iDVAL(mCCD_DVAL),
	.oRed(sCCD_R),
	.oGreen(sCCD_G),
	.oBlue(sCCD_B),
	.oDVAL(sCCD_DVAL),
	.iX_Cont(X_Cont),
	.iY_Cont(Y_Cont)
);
`else
RAW2RGB		u4	(	
	.iCLK(D5M_PIXLCLK),
	.iRST_n(DLY_RST_1),
	.iData(mCCD_DATA),
	.iDval(mCCD_DVAL),
	.oRed(sCCD_R),
	.oGreen(sCCD_G),
	.oBlue(sCCD_B),
	.oDval(sCCD_DVAL),
	.iZoom(SW[16]),
	.iX_Cont(X_Cont),
	.iY_Cont(Y_Cont)
);
`endif

Reset_Delay		u2	(	//Reset module
	.iCLK(CLOCK2_50),
	.iRST(KEY[0]),
	.oRST_0(DLY_RST_0),
	.oRST_1(DLY_RST_1),
	.oRST_2(DLY_RST_2),
	.oRST_3(DLY_RST_3),
	.oRST_4(DLY_RST_4)
);

CCD_Capture		u3	(	//D5M image capture
	.oDATA(mCCD_DATA),
	.oDVAL(mCCD_DVAL),
	.oX_Cont(X_Cont),
	.oY_Cont(Y_Cont),
	.oFrame_Cont(Frame_Cont),
	.iDATA(rCCD_DATA),
	.iFVAL(rCCD_FVAL),
	.iLVAL(rCCD_LVAL),
	.iSTART(rs232_finish||auto_start),
	.iEND(!KEY[3]),
	.iCLK(~D5M_PIXLCLK),
	.iRST(DLY_RST_2)
);

VGA_Controller		u1	(	//VGA DISPLAY
	.oRequest(Read),
	.iRed(final_r),
	.iGreen(final_g),
	.iBlue(final_b),
	//	VGA Side
	.oVGA_R(oVGA_R),
	.oVGA_G(oVGA_G),
	.oVGA_B(oVGA_B),
	.oVGA_H_SYNC(VGA_HS),
	.oVGA_V_SYNC(VGA_VS),
	.oVGA_SYNC(VGA_SYNC_N),
	.oVGA_BLANK(VGA_BLANK_N),
	//	Control Signal
	.iCLK(VGA_CTRL_CLK),
	.iRST_N(DLY_RST_2),
	.iZOOM_MODE_SW(SW[16])
);

RGB2GS	u9	(
	.iRed(sCCD_R),
	.iGreen(sCCD_G),
	.iBlue(sCCD_B),
	.oGreyscale(sCCD_GS)
);

					
sdram_pll	u6	(
	.inclk0(CLOCK2_50),
	.c0(sdram_ctrl_clk),
	.c1(DRAM_CLK),
	.c2(D5M_XCLKIN), //25M
	
	`ifdef VGA_640x480p60
		.c3(VGA_CLK)     //25M 
	`else
		 .c4(VGA_CLK)     //40M 	
	`endif
						);
						
Sdram_Control	u7	(	//	HOST Side						
	.RESET_N(KEY[0]),
	.CLK(sdram_ctrl_clk),
	.REF_PER(ref_per),

	//	FIFO Write Side 1
	//.WR1_DATA({1'b0,sCCD_SGreen[11:7],sCCD_SRed[11:2]}),
	.WR1_DATA({1'b0,sCCD_G[11:7],sCCD_R[11:2]}),
	.WR1(sCCD_DVAL),
	.WR1_ADDR(0),
	
	`ifdef VGA_640x480p60
		.WR1_MAX_ADDR(640*480/2),
		.WR1_LENGTH(8'h50),
	`else
		.WR1_MAX_ADDR(800*600/2),
		.WR1_LENGTH(8'h80),
	`endif	
						
	.WR1_LOAD(!DLY_RST_0),
	.WR1_CLK(D5M_PIXLCLK),

	//	FIFO Write Side 2
	//.WR2_DATA({1'b0,sCCD_SGreen[6:2],sCCD_SBlue[11:2]}),
	.WR2_DATA({1'b0,sCCD_G[6:2],sCCD_B[11:2]}),
	.WR2(sCCD_DVAL),
	//.WR2_ADDR(23'h100000),
	.WR2_ADDR(23'd307200+23'h100000),
	
	`ifdef VGA_640x480p60
		// .WR2_MAX_ADDR(23'h100000+640*480/2),
		.WR2_MAX_ADDR(23'h100000+23'd307200+640*480/2),
		.WR2_LENGTH(8'h50),
	`else							
		.WR2_MAX_ADDR(23'h100000+23'd307200+800*600/2),
		//.WR2_MAX_ADDR(23'd240000+800*600/2),
		.WR2_LENGTH(8'h80),
	`endif	

	.WR2_LOAD(!DLY_RST_0),
	.WR2_CLK(D5M_PIXLCLK),

	//	FIFO Read Side 1
	.RD1_DATA(Read_DATA1),
	.RD1(Read),
	.RD1_ADDR(0),
	
	`ifdef VGA_640x480p60
		.RD1_MAX_ADDR(640*480/2),
		.RD1_LENGTH(8'h50),
	`else
		.RD1_MAX_ADDR(800*600/2),
		.RD1_LENGTH(8'h80),
	`endif
	
	.RD1_LOAD(!DLY_RST_0),
	.RD1_CLK(~VGA_CTRL_CLK),
	
	//	FIFO Read Side 2
	 .RD2_DATA(Read_DATA2),
	.RD2(Read),
	//.RD2_ADDR(23'h100000),
	.RD2_ADDR(23'h100000+23'd307200),
	
	`ifdef VGA_640x480p60
		 //.RD2_MAX_ADDR(23'h100000+640*480/2),
		.RD2_MAX_ADDR(23'h100000+23'd307200+640*480/2),
		.RD2_LENGTH(8'h50),
	`else
		.RD2_MAX_ADDR(23'h100000+23'd307200+800*600/2),
		//.RD2_MAX_ADDR(23'd240000+800*600/2),
		.RD2_LENGTH(8'h80),
	`endif
	
	.RD2_LOAD(!DLY_RST_0),
	.RD2_CLK(~VGA_CTRL_CLK),
	
	//	SDRAM Side
	.SA(DRAM_ADDR),
	.BA(DRAM_BA),
	.CS_N(DRAM_CS_N),
	.CKE(DRAM_CKE),
	.RAS_N(DRAM_RAS_N),
	.CAS_N(DRAM_CAS_N),
	.WE_N(DRAM_WE_N),
	.DQ(DRAM_DQ),
	.DQM(DRAM_DQM)
						);

I2C_CCD_Config		u8	(	//D5M I2C control
	.iCLK(CLOCK2_50),
	.iRST_N(DLY_RST_2),
	.iEXPOSURE_ADJ(KEY[1]),
	.iEXPOSURE_DEC_p(SW[0]),
	.iZOOM_MODE_SW(SW[16]),
	//	I2C Side
	.I2C_SCLK(D5M_SCLK),
	.I2C_SDAT(D5M_SDATA)
);




Signal_comb sc1(
	.iclk(VGA_CTRL_CLK),
	.irst_n(DLY_RST_2),
	.iRed_1(Read_DATA1[9:0]),
	.iGreen_1({Read_DATA1[14:10],Read_DATA2[14:10]}),
	.iBlue_1(Read_DATA2[9:0]),
	.iRed_2(pro_data_r),
	.iGreen_2(pro_data_g),
	.iBlue_2(pro_data_b),
	.iTrans(pro_data_trans),
	.slt(slt),
	.now_x(now_x),
	.now_y(now_y),
	.oRed(final_r),
	.oGreen(final_g),
	.oBlue(final_b)
);

sram_rs232 (
	.clock(VGA_CTRL_CLK),
	.data(sram_rs232_wdata_r),
	//.data(8'd87),
	.rdaddress(sram_rs232_raddr_r),
	.wraddress(sram_rs232_waddr_r),
	.wren(sram_rs232_wren_r),
	.q(sram_rs232_rdata)
);				

rs232_qsys (
	.clk_clk(CLOCK_50),
	.reset_reset_n(KEY[0]),
	.uart_0_external_connection_rxd(UART_RXD),
	.uart_0_external_connection_txd(UART_TXD),
	.sram_rs232_data(sram_rs232_rdata_r),
	.send_start(!KEY[3]),
	.send_finished(rs232_finish),
	.sram_rs232_addr(sram_rs232_raddr),
	.rs232_state(rs232_state)
);	

Filter_tran filter(
	.num(face_num),
	.style(style_mode),
	.pos_x1(pos_x1),
	.pos_y1(pos_y1),
	.eyerow11(eye_y[0][0]),
	.eyerow12(eye_y[0][1]),
	.eyecol11(eye_x[0][0]),
	.eyecol12(eye_x[0][1]),
	.pos_x2(pos_x2),
	.pos_y2(pos_y2),
	.eyerow21(eye_y[1][0]),
	.eyerow22(eye_y[1][1]),
	.eyecol21(eye_x[1][0]),
	.eyecol22(eye_x[1][1]),
	.width(filter_width),
	.height(filter_height),
	.now_x(now_x),
	.now_y(now_y),
	.rom_addr0(filter_addr0),
	.rom_addr1(filter_addr1),
	.rom_data0(filter_rdata0),
	.rom_data1(filter_rdata1),
	.rom_data2(filter3_rdata),
	.pro_data_r(pro_data_r),
	.pro_data_g(pro_data_g),
	.pro_data_b(pro_data_b),
	.pro_data_trans(pro_data_trans),
	.slt(slt)
);

viola_jones#(
	.width(80),
	.height(60),
	.window_size(30)
	) viola (
	.clk(VGA_CTRL_CLK),
	.rst(DLY_RST_2),
   .start(model_start),
   .col1(pos_x1),
   .row1(pos_y1),
	.eyerow11(eye_y[0][0]),
	.eyerow12(eye_y[0][1]),
	.eyecol11(eye_x[0][0]),
	.eyecol12(eye_x[0][1]),
   .col2(pos_x2),
   .row2(pos_y2),
	.eyerow21(eye_y[1][0]),
	.eyerow22(eye_y[1][1]),
	.eyecol21(eye_x[1][0]),
	.eyecol22(eye_x[1][1]),
   .col3(pos_x3),
   .row3(pos_y3),
	.eyerow31(eye_y[2][0]),
	.eyerow32(eye_y[2][1]),
	.eyecol31(eye_x[2][0]),
	.eyecol32(eye_x[2][1]),
   .num(face_num),
   .addr(sram_addr2),
   .data(sram_rdata),
   .we_n(sram_wren2),
   .finish(model_finish),
	.o_state(viola_state),
	.o_col(viola_col),
	.o_row(viola_row),
	.o_frame(viola_frame),
	.o_skin_counter(skin_counter),
	.o_hair_counter(hair_counter)
);	


sram s1(
	.address(sram_addr),
	.clock(VGA_CTRL_CLK),
	.data(sram_wdata),
	.wren(sram_wren),
	.q(sram_rdata)
);

Save_pic savepic(
	.clk(VGA_CTRL_CLK),
	.rst_n(DLY_RST_2),
	.data_r(Read_DATA1[9:0]),
	.data_g({Read_DATA1[14:10],Read_DATA2[14:10]}),
	.data_b(Read_DATA2[9:0]),
	.model_finish(model_finish),
	.i_data(sram_rdata),
	.now_x(now_x),
	.now_y(now_y),
	.sram_wren(sram_wren1),
	.sram_addr(sram_addr1),
	.sram_data(sram_wdata),
	.model_start(model_start),
	.state(save_state)
);




SEG7_LUT_8	v_frame	(	//SEG7 display
	.oSEG0(HEX0),.oSEG1(HEX1),
	.oSEG2(HEX2),.oSEG3(HEX3),
	.oSEG4(),.oSEG5(),
	.oSEG6(),.oSEG7(),
	.iDIG(SW[15] ? pos_x1*256+pos_y1 : eye_x[0][0]*256+ eye_y[0][0])
);


SEG7_LUT_8	v_frame1	(	
	.oSEG0(HEX4),.oSEG1(HEX5),
	.oSEG2(HEX6),.oSEG3(HEX7),
	.oSEG4(),.oSEG5(),
	.oSEG6(),.oSEG7(),
	//.iDIG(SW[16]?sram_rdata:(face_num + pos_x1*256))
	.iDIG(face_num * 256 + style_mode)
	);

test2port r1(
   .clock(VGA_CTRL_CLK),
	.address_a(filter_addr0),
	.address_b(filter_addr1),
	.q_a(filter1_rdata0),
	.q_b(filter1_rdata1)
);

pic2_rom r2(
   .clock(VGA_CTRL_CLK),
	.address_a(filter_addr0),
	.address_b(filter_addr1),
	.q_a(filter2_rdata0),
	.q_b(filter2_rdata1)
);

eyeball reye(
   .clock(VGA_CTRL_CLK),
	.address(filter_addr0),
	.q(filter3_rdata)
);

sunglasses rsun(
   .clock(VGA_CTRL_CLK),
	.address_a(filter_addr0),
	.address_b(filter_addr1),
	.q_a(filter4_rdata0),
	.q_b(filter4_rdata1)
);



always@(*) begin
	style_mode_w = style_mode_r;
end

//D5M read 
always@(posedge D5M_PIXLCLK) begin
	rCCD_DATA	<=	D5M_D;
	rCCD_LVAL	<=	D5M_LVAL;
	rCCD_FVAL	<=	D5M_FVAL;
end

always @(posedge KEY[3] or negedge DLY_RST_2) begin
	//if(!DLY_RST_2) begin
		ref_per <= 10'd700;
	//end
end

always @(posedge KEY[2] or negedge DLY_RST_2) begin
	if(!DLY_RST_2) style_mode_r <= 2'd0;
	else 				style_mode_r <= style_mode_w + 1;
end

always @(posedge VGA_CTRL_CLK) begin
	sram_rs232_raddr_r	<= sram_rs232_raddr;
	sram_rs232_waddr_r	<= sram_rs232_waddr;
	sram_rs232_wdata_r	<= sram_rs232_wdata;
	sram_rs232_rdata_r	<= sram_rs232_rdata;
	sram_rs232_wren_r		<= sram_rs232_wren;
	
end

endmodule
					

